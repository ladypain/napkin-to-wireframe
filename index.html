<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creador de Wireframes Mejorado</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .layout {
            display: flex;
            gap: 20px;
        }
        .canvas-area {
            flex: 1;
        }
        .sidebar {
            width: 300px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        .canvas-container {
            margin: 20px 0;
            border: 2px solid #eee;
            border-radius: 4px;
        }
        .tools {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 8px 16px;
            background: #0066ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #0052cc;
        }
        button.secondary {
            background: #f0f0f0;
            color: #333;
        }
        button.secondary:hover {
            background: #e0e0e0;
        }
        .element-preview {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .guide {
            margin-bottom: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        .guide h3 {
            margin-top: 0;
        }
        .guide ul {
            padding-left: 20px;
            margin: 0;
        }
        #interpretedElements {
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Creador de Wireframes</h1>
        
        <div class="layout">
            <div class="canvas-area">
                <div class="tools">
                    <button onclick="toggleDrawingMode()">Modo Dibujo</button>
                    <button onclick="clearCanvas()" class="secondary">Limpiar</button>
                    <button onclick="interpretWireframe()">Interpretar</button>
                    <button onclick="downloadWireframe()" class="secondary">Descargar</button>
                </div>
                <canvas id="wireframe-canvas" width="800" height="600"></canvas>
            </div>
            
            <div class="sidebar">
                <div class="guide">
                    <h3>Guía de Dibujo</h3>
                    <ul>
                        <li>⭕ Círculo = Radio button</li>
                        <li>⭕• Círculo con punto = Radio button seleccionado</li>
                        <li>☐ Cuadrado = Checkbox</li>
                        <li>☑️ Cuadrado con tick = Checkbox seleccionado</li>
                        <li>*Texto = Header</li>
                        <li>Texto normal = Label</li>
                        <li>▭ Rectángulo = Input/Botón</li>
                    </ul>
                </div>
                <h3>Elementos Interpretados</h3>
                <div id="interpretedElements"></div>
            </div>
        </div>
    </div>

    <script>
        // Inicializar el canvas
        const canvas = new fabric.Canvas('wireframe-canvas', {
            isDrawingMode: true,
            backgroundColor: 'white'
        });

        // Configurar el pincel
        canvas.freeDrawingBrush.width = 2;
        canvas.freeDrawingBrush.color = "#000000";

        // Variables de control
        let isDrawingMode = true;
        
        // Diccionario de patrones de elementos
        const elementPatterns = {
            isCircle: (path) => {
                const bounds = path.getBoundingRect();
                return Math.abs(bounds.width - bounds.height) < 10 && 
                       bounds.width < 50 && 
                       isClosedPath(path);
            },
            isSquare: (path) => {
                const bounds = path.getBoundingRect();
                return Math.abs(bounds.width - bounds.height) < 10 && 
                       bounds.width < 50 && 
                       isRectangular(bounds);
            },
            isRectangle: (path) => {
                const bounds = path.getBoundingRect();
                return bounds.width > bounds.height * 1.5 && 
                       isRectangular(bounds);
            },
            isText: (path) => {
                const bounds = path.getBoundingRect();
                return bounds.width > 10 && bounds.height < 30;
            }
        };

        // Función para interpretar el tipo de elemento
        function interpretElement(path) {
            const bounds = path.getBoundingRect();
            
            if (elementPatterns.isCircle(path)) {
                // Verificar si tiene un punto en el centro para radio button seleccionado
                return { type: 'radio button', state: hasInnerDot(path) ? 'selected' : 'unselected' };
            }
            
            if (elementPatterns.isSquare(path)) {
                // Verificar si tiene un tick para checkbox seleccionado
                return { type: 'checkbox', state: hasTick(path) ? 'selected' : 'unselected' };
            }
            
            if (elementPatterns.isRectangle(path)) {
                return { type: 'input/button', width: bounds.width, height: bounds.height };
            }
            
            if (elementPatterns.isText(path)) {
                // Verificar si comienza con * para header
                const isHeader = path.path.some(p => p[0] === '*');
                return { type: isHeader ? 'header' : 'label' };
            }
            
            return { type: 'unknown' };
        }

        // Función para detectar un punto central (radio button seleccionado)
        function hasInnerDot(path) {
            const bounds = path.getBoundingRect();
            const center = path.getCenterPoint();
            return path.path.some(p => 
                Math.abs(p[1] - center.x) < 5 && 
                Math.abs(p[2] - center.y) < 5
            );
        }

        // Función para detectar un tick (checkbox seleccionado)
        function hasTick(path) {
            // Implementar detección de tick
            return false; // Por ahora retornamos false
        }

        // Mejorar la detección de formas después de dibujar
        canvas.on('path:created', function(e) {
            const path = e.path;
            const interpreted = interpretElement(path);
            
            // Convertir a forma limpia según el tipo
            switch(interpreted.type) {
                case 'radio button':
                    createCleanRadioButton(path, interpreted.state === 'selected');
                    break;
                case 'checkbox':
                    createCleanCheckbox(path, interpreted.state === 'selected');
                    break;
                case 'input/button':
                    createCleanRectangle(path);
                    break;
                // Los textos se dejan como están
                default:
                    break;
            }
        });

        // Funciones para crear elementos limpios
        function createCleanRadioButton(path, selected) {
            const bounds = path.getBoundingRect();
            const circle = new fabric.Circle({
                left: bounds.left,
                top: bounds.top,
                radius: bounds.width / 2,
                stroke: '#000000',
                strokeWidth: 2,
                fill: 'transparent'
            });
            
            if (selected) {
                const dot = new fabric.Circle({
                    left: bounds.left + bounds.width / 4,
                    top: bounds.top + bounds.height / 4,
                    radius: bounds.width / 4,
                    fill: '#000000'
                });
                canvas.add(dot);
            }
            
            canvas.remove(path);
            canvas.add(circle);
            canvas.renderAll();
        }

        function createCleanCheckbox(path, selected) {
            const bounds = path.getBoundingRect();
            const rect = new fabric.Rect({
                left: bounds.left,
                top: bounds.top,
                width: bounds.width,
                height: bounds.height,
                stroke: '#000000',
                strokeWidth: 2,
                fill: 'transparent'
            });
            
            canvas.remove(path);
            canvas.add(rect);
            canvas.renderAll();
        }

        function createCleanRectangle(path) {
            const bounds = path.getBoundingRect();
            const rect = new fabric.Rect({
                left: bounds.left,
                top: bounds.top,
                width: bounds.width,
                height: bounds.height,
                stroke: '#000000',
                strokeWidth: 2,
                fill: 'transparent'
            });
            
            canvas.remove(path);
            canvas.add(rect);
            canvas.renderAll();
        }

        // Funciones auxiliares
        function isClosedPath(path) {
            if (path.path.length < 2) return false;
            const start = path.path[0];
            const end = path.path[path.path.length - 1];
            return Math.abs(start[1] - end[1]) < 10 && 
                   Math.abs(start[2] - end[2]) < 10;
        }

        function isRectangular(bounds) {
            return bounds.width > 10 && bounds.height > 10;
        }

        // Funciones de control existentes
        function toggleDrawingMode() {
            isDrawingMode = !isDrawingMode;
            canvas.isDrawingMode = isDrawingMode;
        }

        function clearCanvas() {
            canvas.clear();
            canvas.backgroundColor = 'white';
            canvas.renderAll();
            document.getElementById('interpretedElements').innerHTML = '';
        }

        function interpretWireframe() {
            const objects = canvas.getObjects();
            const interpretedElements = objects.map(obj => interpretElement(obj));
            
            // Mostrar elementos interpretados
            const container = document.getElementById('interpretedElements');
            container.innerHTML = interpretedElements.map(elem => `
                <div class="element-preview">
                    <strong>${elem.type}</strong>
                    ${elem.state ? `<br>Estado: ${elem.state}` : ''}
                    ${elem.width ? `<br>Dimensiones: ${Math.round(elem.width)}x${Math.round(elem.height)}` : ''}
                </div>
            `).join('');
        }

        function downloadWireframe() {
            const dataURL = canvas.toDataURL({
                format: 'png',
                quality: 1
            });
            const link = document.createElement('a');
            link.download = 'wireframe.png';
            link.href = dataURL;
            link.click();
        }
    </script>
</body>
</html>
