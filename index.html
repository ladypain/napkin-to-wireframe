<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creador de Wireframes Avanzado</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        /* [Estilos anteriores se mantienen igual...] */
    </style>
</head>
<body>
    <!-- [La estructura HTML se mantiene igual...] -->

    <script>
        // [Inicialización de canvas y configuraciones básicas se mantienen igual...]

        function interpretElement(path) {
            const bounds = path.getBoundingRect();
            
            if (isCircularShape(path)) {
                return { 
                    type: 'radio button', 
                    selected: hasInnerDot(path), 
                    bounds: bounds 
                };
            }
            
            if (isSquareShape(path)) {
                return { 
                    type: 'checkbox', 
                    checked: hasInnerMark(path), 
                    bounds: bounds 
                };
            }
            
            if (bounds.width > bounds.height * 1.5 && bounds.height > 20) {
                return { type: 'input/button', bounds: bounds };
            }
            
            // Mejorada la detección de texto
            if (isTextShape(path)) {
                return { type: 'label', text: extractText(path), bounds: bounds };
            }
            
            return { type: 'unknown', bounds: bounds };
        }

        function isCircularShape(path) {
            const bounds = path.getBoundingRect();
            const area = bounds.width * bounds.height;
            const perimeter = path.length;
            const circularity = (4 * Math.PI * area) / (perimeter * perimeter);
            return circularity > 0.7 && Math.abs(bounds.width - bounds.height) < 10;
        }

        function isSquareShape(path) {
            const bounds = path.getBoundingRect();
            return Math.abs(bounds.width - bounds.height) < 10 && bounds.width < 50;
        }

        function isTextShape(path) {
            // Implementar una lógica más sofisticada para detectar formas de texto
            return path.height < 30 && path.width > path.height * 2;
        }

        function extractText(path) {
            // Aquí se implementaría la lógica de OCR para extraer texto
            // Por ahora, simplemente devolvemos "Label"
            return "Label";
        }

        function hasInnerDot(path) {
            // [Lógica mejorada para detectar puntos internos...]
        }

        function hasInnerMark(path) {
            // [Lógica mejorada para detectar marcas internas...]
        }

        function drawRefinedShape(interpretation, standardSize) {
            let shape;
            const bounds = interpretation.bounds;

            switch(interpretation.type) {
                case 'radio button':
                    shape = new fabric.Circle({
                        left: bounds.left,
                        top: bounds.top,
                        radius: standardSize / 2,
                        stroke: '#000000',
                        strokeWidth: 2,
                        fill: 'transparent'
                    });
                    if (interpretation.selected) {
                        const dot = new fabric.Circle({
                            left: bounds.left + standardSize / 4,
                            top: bounds.top + standardSize / 4,
                            radius: standardSize / 4,
                            fill: '#000000'
                        });
                        refinedCanvas.add(dot);
                    }
                    break;

                case 'checkbox':
                    shape = new fabric.Rect({
                        left: bounds.left,
                        top: bounds.top,
                        width: standardSize,
                        height: standardSize,
                        stroke: '#000000',
                        strokeWidth: 2,
                        fill: 'transparent'
                    });
                    if (interpretation.checked) {
                        const check = new fabric.Text('✓', {
                            left: bounds.left + standardSize / 4,
                            top: bounds.top,
                            fontSize: standardSize,
                            fill: '#000000'
                        });
                        refinedCanvas.add(check);
                    }
                    break;

                case 'input/button':
                    shape = new fabric.Rect({
                        left: bounds.left,
                        top: bounds.top,
                        width: Math.max(bounds.width, 100),
                        height: bounds.height,
                        stroke: '#000000',
                        strokeWidth: 2,
                        fill: 'transparent',
                        rx: 4,
                        ry: 4
                    });
                    break;

                case 'label':
                    shape = new fabric.Text(interpretation.text, {
                        left: bounds.left,
                        top: bounds.top,
                        fontSize: 14,
                        fill: '#000000'
                    });
                    break;
            }

            if (shape) {
                refinedCanvas.add(shape);
            }
        }

        function interpretWireframe() {
            refinedCanvas.clear();
            refinedCanvas.backgroundColor = 'white';

            const objects = drawingCanvas.getObjects();
            const interpretedElements = [];

            // Calcular tamaño estándar para checks y radios
            const standardSize = calculateStandardSize(objects);

            // Primera pasada: interpretar y agrupar elementos
            const groupedElements = groupSimilarElements(objects.map(obj => interpretElement(obj)));

            // Segunda pasada: dibujar elementos refinados
            groupedElements.forEach(group => {
                group.forEach((elem, index) => {
                    // Alinear elementos en el mismo grupo
                    if (index > 0) {
                        elem.bounds.top = group[0].bounds.top;
                    }
                    drawRefinedShape(elem, standardSize);
                    interpretedElements.push(elem);
                });
            });

            // Actualizar panel lateral
            updateSidebar(interpretedElements);

            refinedCanvas.renderAll();
            showMessage('¡Wireframe interpretado! Revisa el canvas derecho para ver el resultado.');
        }

        function calculateStandardSize(objects) {
            const sizes = objects
                .filter(obj => obj.type === 'path')
                .map(obj => Math.min(obj.width, obj.height))
                .filter(size => size < 50 && size > 10);
            return sizes.length ? Math.round(sizes.reduce((a, b) => a + b) / sizes.length) : 30;
        }

        function groupSimilarElements(elements) {
            // Agrupar elementos similares que estén cerca unos de otros
            const groups = [];
            elements.forEach(elem => {
                const existingGroup = groups.find(group => 
                    group[0].type === elem.type && 
                    Math.abs(group[0].bounds.left - elem.bounds.left) < 50
                );
                if (existingGroup) {
                    existingGroup.push(elem);
                } else {
                    groups.push([elem]);
                }
            });
            return groups;
        }

        function updateSidebar(interpretedElements) {
            const container = document.getElementById('interpretedElements');
            container.innerHTML = interpretedElements.map(elem => `
                <div class="element-preview">
                    <strong>${elem.type}</strong>
                    ${elem.selected !== undefined ? `<br>Seleccionado: ${elem.selected}` : ''}
                    ${elem.checked !== undefined ? `<br>Marcado: ${elem.checked}` : ''}
                    ${elem.text ? `<br>Texto: ${elem.text}` : ''}
                    <br>Posición: (${Math.round(elem.bounds.left)}, ${Math.round(elem.bounds.top)})
                    <br>Tamaño: ${Math.round(elem.bounds.width)}x${Math.round(elem.bounds.height)}
                </div>
            `).join('');
        }

        // [Otras funciones auxiliares como toggleDrawingMode, clearCanvases, downloadWireframe se mantienen igual...]
    </script>
</body>
</html>
